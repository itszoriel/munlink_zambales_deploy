"""PDF table report utilities using reportlab.

Generates simple, branded PDF reports with header/footer and zebra table.
"""

from typing import List, Dict, Any, Tuple
from datetime import datetime
from pathlib import Path
import os

from reportlab.lib.pagesizes import A4
from reportlab.pdfgen import canvas
from reportlab.lib import colors
from reportlab.lib.units import mm
try:
    # Reuse official document styling helpers (border, header, watermark)
    from apps.api.utils.pdf_generator import _resolve_logo_paths, _draw_header, _draw_watermark, _draw_border
except Exception:  # pragma: no cover
    _resolve_logo_paths = None
    _draw_header = None
    _draw_watermark = None
    _draw_border = None


def _draw_header_footer(c: canvas.Canvas, title: str, municipality_name: str, page_w: int, page_h: int):
    c.setFillColor(colors.black)
    c.setFont('Helvetica-Bold', 12)
    # Centered municipal name & report title similar to document PDFs
    c.drawCentredString(page_w/2, page_h - 34*mm, municipality_name)
    c.setFont('Helvetica', 10)
    c.setFillColor(colors.grey)
    c.drawCentredString(page_w/2, page_h - 40*mm, title)
    c.setFillColor(colors.black)

    # Footer (centered)
    c.setFont('Helvetica', 8)
    c.setFillColor(colors.grey)
    c.drawCentredString(page_w/2, 16*mm, f"Generated by MunLink Zambales • {datetime.utcnow().strftime('%Y-%m-%d %H:%M UTC')}")


def _fit_text(c: canvas.Canvas, text: str, max_width: float, font_name: str = 'Helvetica', font_size: int = 9) -> str:
    """Truncate text with ellipsis to fit within max_width."""
    c.setFont(font_name, font_size)
    if c.stringWidth(text, font_name, font_size) <= max_width:
        return text
    # Reserve width for ellipsis
    ell = '…'
    ell_w = c.stringWidth(ell, font_name, font_size)
    # Binary trim
    low, high = 0, len(text)
    best = ''
    while low <= high:
        mid = (low + high) // 2
        candidate = text[:mid] + ell
        if c.stringWidth(candidate, font_name, font_size) <= max_width:
            best = candidate
            low = mid + 1
        else:
            high = mid - 1
    return best or ell


def _compute_col_widths(c: canvas.Canvas, headers: List[str], rows: List[List[Any]], total_width: float, font_name: str='Helvetica', font_size: int=9) -> List[float]:
    """Compute proportional column widths based on content, with sane min/max caps.
    We sample headers and first N rows to estimate width, then normalize to total_width.
    """
    sample_rows = rows[:50]  # limit for speed
    c.setFont(font_name, font_size)
    estimates: List[float] = []
    for ci, h in enumerate(headers):
        max_w = c.stringWidth(str(h), font_name, font_size) + 6*mm
        for r in sample_rows:
            if ci < len(r):
                w = c.stringWidth(str(r[ci]), font_name, font_size) + 6*mm
                if w > max_w:
                    max_w = w
        # Clamp each column between 18mm and 70mm
        max_w = max(18*mm, min(70*mm, max_w))
        estimates.append(max_w)
    # Normalize to total width
    s = sum(estimates) or 1.0
    return [total_width * (w / s) for w in estimates]


def generate_table_pdf(
    *,
    out_path: Path,
    title: str,
    municipality_name: str,
    headers: List[str],
    rows: List[List[Any]],
) -> Path:
    out_path.parent.mkdir(parents=True, exist_ok=True)
    page_w, page_h = A4
    c = canvas.Canvas(str(out_path), pagesize=A4)

    # Branded header (seal + government header) and watermark like document PDFs
    if _draw_border:
        try:
            _draw_border(c)
        except Exception:
            pass
    # Try to resolve logos and draw header/watermark
    mun_logo = prov_logo = None
    if _resolve_logo_paths:
        try:
            mun_logo, prov_logo = _resolve_logo_paths(municipality_name)
        except Exception:
            mun_logo = prov_logo = None
    if _draw_header:
        try:
            _draw_header(c, municipality_name, mun_logo, prov_logo, level='municipal')
        except Exception:
            pass
    if _draw_watermark and mun_logo is not None:
        try:
            _draw_watermark(c, mun_logo, opacity=0.20, size_mm=220.0)
        except Exception:
            pass
    # Also draw a minimal subtitle line under header for context
    _draw_header_footer(c, title, municipality_name, page_w, page_h)

    # Table area
    x = 20*mm
    # Drop the table lower to clear header & watermark title
    y = page_h - 72*mm
    table_width = (page_w - 40*mm)
    # Compute adaptive column widths
    col_widths = _compute_col_widths(c, headers, rows, table_width)
    row_h = 8*mm

    # Header row
    c.setFillColor(colors.lightgrey)
    c.rect(x, y, sum(col_widths), row_h, stroke=0, fill=1)
    c.setFillColor(colors.black)
    c.setFont('Helvetica-Bold', 9)
    cx = x
    for i, h in enumerate(headers):
        w = col_widths[i]
        txt = _fit_text(c, str(h), w - 4*mm, 'Helvetica-Bold', 9)
        c.drawString(cx + 2*mm, y + 2*mm, txt)
        cx += w
    y -= row_h

    c.setFont('Helvetica', 9)
    # Rows (paginate if needed)
    for r_idx, r in enumerate(rows):
        if y < 20*mm:
            c.showPage()
            _draw_header_footer(c, title, municipality_name, page_w, page_h)
            y = page_h - 40*mm
            # redraw header
            c.setFillColor(colors.lightgrey)
            c.rect(x, y, sum(col_widths), row_h, stroke=0, fill=1)
            c.setFillColor(colors.black)
            c.setFont('Helvetica-Bold', 9)
            cx = x
            for i, h in enumerate(headers):
                w = col_widths[i]
                txt = _fit_text(c, str(h), w - 4*mm, 'Helvetica-Bold', 9)
                c.drawString(cx + 2*mm, y + 2*mm, txt)
                cx += w
            y -= row_h
            c.setFont('Helvetica', 9)

        if r_idx % 2 == 1:
            c.setFillColor(colors.whitesmoke)
            c.rect(x, y, sum(col_widths), row_h, stroke=0, fill=1)
        c.setFillColor(colors.black)
        cx = x
        for i, cell in enumerate(r):
            w = col_widths[i]
            txt = _fit_text(c, str(cell), w - 4*mm, 'Helvetica', 9)
            c.drawString(cx + 2*mm, y + 2*mm, txt)
            cx += w
        y -= row_h

    c.showPage()
    c.save()
    return out_path


